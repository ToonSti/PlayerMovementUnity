/*

// call in void update
// horizontal movement
Vector3 movement = new Vector3(x, 0, z);                    // make the movement variable
movement = Vector3.ClampMagnitude(movement, 1);             // make sure maximal speed is 1 to every side (normalize)
transform.Translate(movement * speed * Time.deltaTime);     // apply movement to object

// call in update
// vertical movement (jumping)
rb.AddForce(new Vector2(0f, jumpForce));                    // apply force up with an amount of force

float x = Input.GetAxis("Horizontal");                      // get the input corresponding to the x axis
float z = Input.GetAxis("Vertical");                        // get the input corresponding to the z axis


For the animation PlayerMove, I could have just sped up the PlayerIdle animation, but since you will probably never use the Idle animation sped up, I changed the animation anyway.
In case you would like to speed up your animation:
    https://docs.unity3d.com/ScriptReference/Animator-speed.html
I dont know if this is the best and correct way of speeding up. 
Since I think you speed up the entire animator with this, you will probably have to set the speed value back to the original when switching to PlayerIdle and before PlayerJump.
(the link is also in Sources under "Other:".)

If the player moves on ground that is not flat, it may be possible to add multiple groundchecks (on every corner for example). 
The conditions for the if statement can be all the groundchecks connected with an or (||).
something like:

private bool isGrounded;

    bool IsGrounded()
    {
        if (Physics.CheckSphere(groundCheck1.position, groundRadius, isGround) || Physics.CheckSphere(groundCheck2.position, groundRadius, isGround) || Physics.CheckSphere(groundCheck3.position, groundRadius, isGround) || Physics.CheckSphere(groundCheck4.position, groundRadius, isGround))  
        {
            isGrounded = true;
        }
        else
        {
            isGrounded = false;
        }
        return isGrounded;
    }

I don't know if that works or even is possible or is the most efficient way, I did not check it yet.

Something I did not check instead of this is this way of making a groundcheck:
    https://www.immersivelimit.com/tutorials/simple-character-controller-for-unity
    (the link is also in Sources under "Other:".)

I would like to try this, so a character works well on slopes, but I have to find the time to understand the Math in C#. It uses a raycast instead of a checksphere.

|                                                                             |
v https://forum.unity.com/threads/third-person-camera-movement-script.858673/ v

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class CameraController : MonoBehaviour
{

    private const float YMin = -90.0f;
    private const float YMax = 90.0f;
    private const float XMin = -90.0f;
    private const float XMax = 90.0f;

    public Transform lookAt;

    public float distance = 10.0f;
    private float currentX = 0.0f;
    private float currentY = 0.0f;
    public float sensivity = 350f;


    // Update is called once per frame
    void FixedUpdate()
    {
        currentX += Input.GetAxis("Mouse X") * sensivity * Time.deltaTime;
        currentY += Input.GetAxis("Mouse Y") * sensivity * Time.deltaTime;

        currentY = Mathf.Clamp(currentY, YMin, YMax);
        currentX = Mathf.Clamp(currentX, XMin, XMax);

        Vector3 Direction = new Vector3(0, 0, -distance);
        Quaternion rotation = Quaternion.Euler(currentY, currentX, 0);
        transform.position = lookAt.position + rotation * Direction;

        transform.LookAt(lookAt.position);
    }
} 
*/